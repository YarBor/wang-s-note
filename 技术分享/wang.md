# 数据结构 0.7 
学数据结构的目的是什么
https://www.zhihu.com/question/31082722
## 链表
在计算机科学中，链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。由于不必须按顺序存储，**链表在插入的时候可以达到O(1)的复杂度**，**比另一种线性表顺序表快得多**，**但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)**。

!!!a 使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。

在计算机科学中，链表作为一种基础的数据结构可以用来生成其它类型的数据结构。链表通常由一连串节点组成，每个节点包含任意的实例数据（data fields）和一或两个用来指向上一个/或下一个节点的位置的链接（"links"）。链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的访问往往要在不同的排列顺序中转换。而链表是一种自我指示数据类型，因为它包含指向另一个相同类型的数据的指针（链接）。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。

- 链表有很多种不同的类型：
  - 单向链表
  - 双向链表
  - 循环链表

- 链表也有如下基本操作
  - 头插 
  - 尾插
  - 头删
  - 尾删
  - 查找
  - 特殊节点删除
  - 节点值更改
### 单向链表
链表中最简单的一种是单向链表，它包含两个域，一个信息域和一个指针域。这个链接指向列表中的下一个节点，而最后一个节点则指向一个空值。
![](https://upload.wikimedia.org/wikipedia/commons/6/6d/Singly-linked-list.svg)
如下为C语言中上述单链表节点的声明
```c
struct list
{
    type_t value;       //你需要存放的具体数据 
    struct list * next; //指向下一个节点的指针
};
```
单链表只能从一个方向进行遍历 所以单链表节点的插入与删除会引入双指针的概念 

> **单链表是链表结构中最基础的结构,在单链表的基础上,派生出了循环链表、双向链表**

### 循环链表
**循环**链表,即与单链表的区别在循环二字
循环链表的最后一个节点的指针域将不再指向NULL
而是指向链表头,从而构成循环
![](https://img-blog.csdnimg.cn/20210505102102837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ4NzI4NzM3,size_16,color_FFFFFF,t_70#pic_center)
这里的双向链表在初始化时与单链表有所不同 会直接将最后的节点指针指向头 在后续插入时 更改指针指向;

### 双向链表
![](https://upload.wikimedia.org/wikipedia/commons/5/5e/Doubly-linked-list.svg)
双向链表的不同之处在其拥有两个指针域,其一指向其前驱节点,其二指向其后继节点,所以在双向链表中,可以很方便的访问它的任意位置
```c
struct DuLNodes {
    type_t value;
    struct DuLNodes *prior;
    struct DuLNodes *next;
};
```
### 哨兵节点
哨兵顾名思义有巡逻、检查的功能，在我们程序中通过增加哨兵结点往往能够简化边界条件，从而防止对特殊条件的判断，使代码更为简便优雅，在链表中应用最为典型。

!!! ! 声明哨兵节点的目的在于: 简化边界条件，从而防止对特殊条件的判断，使代码更为简便  , 使链表更好操控 ;
**哨兵节点与普通节点相同 但数据域为空 , 指针域指向整个链表的头**
- 哨兵节点初始化
  - ```c
    void fun (...)
    {
      // ....
      struct list * list_head = (struct list * )malloc(sizeof(struct list));
      list_head->next=list_node;//需要指向的节点
      // ....
    }
    ```

### 具体实现
上述所有的特点均可自由组合
依照自己在代码中的需求写出符合自身的结构

#### 带哨兵节点的双向循环链表
![](https://img-blog.csdnimg.cn/img_convert/0c2e59064f6a657ce35f0b1f83e4870d.png)

## 栈 -(后进先出)
栈作为一种数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。
它按照后进先出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。

可以形象的理解为枪械的弹夹 入栈==压入子弹 出栈==排出子弹

栈是允许在同一端进行插入和删除操作的特殊线性表。允许进行插入和删除操作的一端称为栈顶(top)，另一端为栈底(bottom)；
栈底固定，而栈顶浮动；栈中元素个数为零时称为空栈。插入一般称为进栈（PUSH），删除则称为退栈（POP）。栈也称为先进后出表。
```c
struct stack {
  type_t * top;
  type_t * bottom;
  int size;//容量
};
```
**栈的实现常用的是顺序表**,为bottom在堆区分配一块大小为`size*sizeof(type_t)`的内存,

入栈时将数据计入top指向的内存块 然后将top++;
入栈时将数据从top-1指向的内存块读出并抹除 然后将top--;

可以用`top-bottom`来计算实际栈的大小
每次入栈都要`实际栈的大小`与`size`进行比较 若相等则需要realloc()进行扩容

> 补充 可以使用栈的概念理解递归调用

## 队列 -(先进先出)
队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。 进行插入操作的端称为队尾，进行删除操作的端称为队头。 队列中没有元素时，称为空队列。 队列的数据元素又称为队列元素。

队列一般来说 会使用链表实现

# md .2

# github 基本操作 .1



